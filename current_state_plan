
7/30/2020
Things complete:
-Basic visuals
-Turn mechanics
-Actors and behaviors
-Movement actions
-Action Resolver basics

Candidates of things to work on:

### NEW FEATURE ###
-Terrain
    Interesting features and environment provide movement obstacles
    Introduces skill challenges for traversing terrain

### PARTIALLY DONE FEATURE ###
-Basic Combat
    Simple Melee attack:
        Weapon-less combat
        combat rolls, damage, etc
        Life cycle mechanics for actors (dying, unconsciousness, etc)

-






9/7/2020
Watched a showcase of numba (used for optimizing python and numpy operations) might be useful for pathfinding, etc.


10/11/2020
### NEW FEATURE ###
Genetics idea:
Each primary and secondary stat will be crossover sites. Pick a combination of both parent, then use normal distribution
to introduce noise (rho being the mutation factor).

Advantages, disadvantages, and innate skills will be passed on by selection:
- one idea, generate a number [0, 1] for each category and that is the percentage one of the parents gives to the child.
The rest of the percentage is how much the other parent gives. (This will mean duplicates will be more likely to be selected)
Introduce a small configurable mutation rate for each adv/dis/innate that will cause a random adv/dis/innate to be selected instead.

Learned skills (languages, non-innate skills, etc) must be TAUGHT.
Teaching will be an action that can be done between two actors with the same language (penalty otherwise).
Teaching is described in the gurps handbook (time to learn will need to be modified)

In order to allow children to learn easier, an innate language between parent and child will give bonuses to teaching.


10/15/2020
### DONE ###
- NOTE: done for movement only. Will change its shape if new actions require it to.
Maneuvers = action objects
have internal structures depending on the maneuver type. Most likely a list of actions.
The maneuver resolve logic will be what validates the counts/order of each action.


10/19/2020
### BACKLOG IDEA ###
Visualization of un-executed moves and failed moves (like an obstacle is in the way)



### DONE ###
Modifiers and Status Effects (buffs adn de-buffs)

Reasons:
Modifiers to stats are required to implement certain status effects (shock, major damage, cripple).

Difficulties:
Currently, movement and combat reference the stat set directly, meaning each of these operate on base stats and no modifiers.
Ideally, the modified stat set should be accessed instead of the regular stat set and both stat sets should be consistent with each other.
The un-modified stat set should still be accessible (since any changes to base stats would happen there.


### NEW FEATURE ###
Life cycle mechanics
Reasons:
- After combat, interaction with the environment, actors can take damage.
- Taking damage has many possible side effects (mostly debuffs and incapacitation/death).
- Currently debuffs have not been implemented (nothing to manage modifiers / debuffs) but to facilitate this
resolving actions should have access to managers that calculate when certain modifiers should be applied, etc.

DEPENDS ON: Status Effects and modifiers (unconsciousness and death are de-buffs)

Example: An actor takes a large amount of damage in combat. This will cause the 'Shock' debuff,  but the action
shouldnt have to implement this directly, since other things can cause shock (movement involving damage).

Debuffs would result after an action is resolved: either triggered by an interaction the action has with the game state,
or directly by the action (status effect).

Triggers:
- abstraction layer watching for changes (in this case for unconsciousness and death)
Flow:
1. action deals damage to actor.
2. right after the health is deducted from the total, an event is emitted for health changing.
3. Event handler(s) determine if any status effects are given to the actor.
4. After setting the valid status effect, a corresponding event is called to handle its effects on turn order (if they have any)

Unconsciousness:
Does not effect turn order, but effects what actions an actor can make on a turn (a forced action to try to regain consciousness)
and Do Nothing.


Turn management flow:
1. Construct turn for actor (advancing turn, generating state)
2. Attach callbacks and resources to ActorFSM for the current actor (callbacks are for submitting actions to be resolved)
3. Start the actorFSM by advancing its state (allowing it to start generating actions) and have main FSM wait in TurnLoop State
4. As actions are generated, the step_complete callback is called, this callback pulls all submitted actions and resolves them.
    4.a [addition]: during the resolution of actions (maneuvers in particular), an actor can die or go unconscious. This
    requires action resolvers to check the consciousness of the actor of a particular action before resolution.


