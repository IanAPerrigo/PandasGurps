
7/30/2020
Things complete:
-Basic visuals
-Turn mechanics
-Actors and behaviors
-Movement actions
-Action Resolver basics

Candidates of things to work on:

### NEW FEATURE ###
-Terrain
    Interesting features and environment provide movement obstacles
    Introduces skill challenges for traversing terrain

### DONE ###
-Basic Combat
    Simple Melee attack:
        Weapon-less combat
        combat rolls, damage, etc
        Life cycle mechanics for actors (dying, unconsciousness, etc)

9/7/2020
Watched a showcase of numba (used for optimizing python and numpy operations) might be useful for pathfinding, etc.


10/11/2020
### NEW FEATURE ###
Genetics idea:
Each primary and secondary stat will be crossover sites. Pick a combination of both parent, then use normal distribution
to introduce noise (rho being the mutation factor).

Advantages, disadvantages, and innate skills will be passed on by selection:
- one idea, generate a number [0, 1] for each category and that is the percentage one of the parents gives to the child.
The rest of the percentage is how much the other parent gives. (This will mean duplicates will be more likely to be selected)
Introduce a small configurable mutation rate for each adv/dis/innate that will cause a random adv/dis/innate to be selected instead.

Learned skills (languages, non-innate skills, etc) must be TAUGHT.
Teaching will be an action that can be done between two actors with the same language (penalty otherwise).
Teaching is described in the gurps handbook (time to learn will need to be modified)

In order to allow children to learn easier, an innate language between parent and child will give bonuses to teaching.


10/15/2020
### DONE ###
- NOTE: done for movement only. Will change its shape if new actions require it to.
Maneuvers = action objects
have internal structures depending on the maneuver type. Most likely a list of actions.
The maneuver resolve logic will be what validates the counts/order of each action.


10/19/2020
### BACKLOG IDEA ###
Visualization of un-executed moves and failed moves (like an obstacle is in the way)



### DONE ###
Modifiers and Status Effects (buffs adn de-buffs)

Reasons:
Modifiers to stats are required to implement certain status effects (shock, major damage, cripple).

Difficulties:
Currently, movement and combat reference the stat set directly, meaning each of these operate on base stats and no modifiers.
Ideally, the modified stat set should be accessed instead of the regular stat set and both stat sets should be consistent with each other.
The un-modified stat set should still be accessible (since any changes to base stats would happen there.

### DONE ###
Add decorators for common action related tasks (checking proximity, checking ranging, consciousness)

### PARTIALLY DONE ###
Life cycle mechanics

##Needs to be completed##
Recovery from unconsciousness and retain consciousness

Reasons:
- After combat, interaction with the environment, actors can take damage.
- Taking damage has many possible side effects (mostly debuffs and incapacitation/death).
- Currently debuffs have not been implemented (nothing to manage modifiers / debuffs) but to facilitate this
resolving actions should have access to managers that calculate when certain modifiers should be applied, etc.

DEPENDS ON: Status Effects and modifiers (unconsciousness and death are de-buffs)

Example: An actor takes a large amount of damage in combat. This will cause the 'Shock' debuff,  but the action
shouldnt have to implement this directly, since other things can cause shock (movement involving damage).

Debuffs would result after an action is resolved: either triggered by an interaction the action has with the game state,
or directly by the action (status effect).

Triggers:
- abstraction layer watching for changes (in this case for unconsciousness and death)
Flow:
1. action deals damage to actor.
2. right after the health is deducted from the total, an event is emitted for health changing.
3. Event handler(s) determine if any status effects are given to the actor.
4. After setting the valid status effect, a corresponding event is called to handle its effects on turn order (if they have any)

Unconsciousness:
Does not effect turn order, but effects what actions an actor can make on a turn (a forced action to try to regain consciousness)
and Do Nothing.


Turn management flow:
1. Construct turn for actor (advancing turn, generating state)
2. Attach callbacks and resources to ActorFSM for the current actor (callbacks are for submitting actions to be resolved)
3. Start the actorFSM by advancing its state (allowing it to start generating actions) and have main FSM wait in TurnLoop State
4. As actions are generated, the step_complete callback is called, this callback pulls all submitted actions and resolves them.
    4.a [addition]: during the resolution of actions (maneuvers in particular), an actor can die or go unconscious. This
    requires action resolvers to check the consciousness of the actor of a particular action before resolution.



### NEW FEATURE ###
Add skills to combat:

- Make combat depend on skills (innate attacks only to begin).

Dependencies:
- Requires skills to be done.

### NEW FEATURE ###
Add weapons to combat:

- Make combat depend on skills and weapons

Dependencies:
- Requires skills to be done.
- Requires inventory and weapons to be done.


### NEW FEATURE ###
Add stances and their bonuses (status effects) to combat:

- Allow maneuvers to modify the posture of the actor (crouching, laying down)
- Allow actors to take defensive maneuvers (all out)

### NEW FEATURE ###
Skills:

- Add learned and innate skills that can be used in certain circumstances.
-

### NEW FEATURE ###
Inventory and equipped items:

- Have items storable in wearable containers on the actor (in the inventory tree).
- Have natural storage locations for anything (hands)
- Have natural storage locations for wearable equipment (body parts)

Dependencies:
- Should require the hit locations structures to be at least added by name (non-functional is okay)


### NEW FEATURE ###
Energy system:

- Create a system to analyze the amount of FP used over time.
    - Sustained use of movement, combat or other actions deemed costly.
- Add "Harvest" and "Eat" actions.
    - Harvest: if target is disabled (unconscious, dead, pinned).
    Target can be an entity with the edible status effect.
    Automatic hit, deal Swing (CUT) damage and gain 1 meal's worth of food.
    When an entity receives the non-existent status, it can no longer be harvested.
    The idea is to have lower HP entities count for less food (weaker and generally smaller)
    Harvested food will be dropped on the floor. An general action to pick up will be added with inventory
    - Eat: consume food nearby or in a container you own
    Add status effect "Eaten N" where N is the number of meals eaten
- Missing a meal:
    A meal is missed if after 1/3 of the day, the actor doesnt have "Eaten 1"
    After a meal period has elapsed, remove a level of Eaten from the active eaten status. If none exists, gain a
    Starvation stack.
- Starvation:
    Starvation requires a whole day of rest + 3 whole meals.
    (might be extreme, here is a test case)
        Rest being interrupted can easily cause death, since anything can ust come along even if the actor ate and was resting.
        Might consider not having "all or nothing" regeneration (as per the rules).
        Consideration: If the actor can eat 3 meals in a day, each meal with the 'rest' buff, then the starvation is gone.
- Dehydration:
    - 2 quarts per day required
        - 8 drinks of water a day
    - Lose 1 FP every 8 hours
        - if less than 1 quart was drank in a day, lose an extra 1 FP and 1 HP
            - Represented by "dehydration N" N being the number of periods of missed water.
            - "Severe dehydration N" is the number of days drinking less than a quart of water.
        - all dehydration debuffs can be removed by ample rest and normal water intake.
- Resting:
    Resting buff is awarded when strenuous activity is avoided for a period of time.
    - Strenuous movement: > 40% maximum movement.
    - Any combat
    - Lifting Extra-Heavy loads (overexertion)
    - Dehydration or starvation nullifies the effects of rest.
    - Rest periods and status-effects
        - Every 10m of rest: +1 FP or +2 with food
    - Sleep:
        - 1 FP per hour uninterrupted
        - Required in last 24 hours otherwise incur penalties (the only reason to do it, since rest is more efficient)

Breakdown (large feature):


# DONE # - Add harvest and eat first, and the status effects given from eating.
- Next, add non-actor entities that count as food (maybe a status effect "edible")
    # DONE # - Also add meal entities that will eventually be able to be picked up.
- Next add a simple 'tick' event system where each turn the tick counter is incremented and an event is sent out.
    A note about this, statuses not tied directly to tick, a status_update event will be called from the tick event
    to keep order of operations in case some priority needs to arise. The status_update will handle registration of
    status updates on particular tick numbers.
    - Further expand on this.
        The status effect object can be broken into a few types:
        # DONE # Countdown status effects: effects that expire after a period of time. This would be like shock, which ticks down over time.
        # DONE # Eternal status effects: always present like fed, hydrated, rest, etc.
            # DONE # Also: periodically updated
        # DONE # Triggered status effects: effects removed by certain circumstances
        TODO: more?
    # DONE # - Handling keeping track of when to update (or potentially remove) status effects.
        A generic way of updating a status effect from one place, without knowing the particulars of each status effect.
        This means, some level of self management is required, but the different classes of statuses are treated as such
        in a manager.

        Add an update_tick function to the status effect class.
        The update_tick function is only called when needed, and using a "next_relevant_tick" field in the status,
        excessive updates can be ignored.
        A flag controlling whether a status should be cleaned up will be the signal of if it should be removed.

        e.g. ShockStatus:
        # Generic fields from StatusEffect
        tick_added = 0
        tick_removed = None
        next_relevant_tick = 1 # Every turn, shock has a modifier reduction.
        active = True

        update_tick(current_tick, time_scale)
        # Update shock modifier
        # check if status has expired
        # if it has expired
            active = False
            next_relevant_tick = None
            # tick_removed will be set by the manager
        # if it didnt expire
            next_relevant_tick += time_scale # Because there is a change every tick (regardless of scale)

        - Now the manager either cleans up the status if it was deactivated or moves onto the next status.
        In the case of eternal statuses, they are never deactivated (unless dead) and have longer time horizons.
        Triggered status effects generally get deactivated when the event happens, assuming they wont need to be worried about here.



# DONE # - Next modify the "fed" and 'quenched' status to be applied on character creation (both at level 0)
    Data associated with each status should be:
        Period begin tick (so day intervals can be calculated to apply the starvation and dehydration updates)


- After all status updates have been completed, update the triggered status effects.
    ### TO FIX ### - Currently starvation and dehydration increase in level on the tick update.
    This is wrong, they should update after a trigger (once every status is updated) to determine if the actor is
    starving or dehydrated. However, the tick update could be used to apply periodic penalties, such as dehydration's
    -1 FP per 8 hours.

        - e.g When an entity is created, the EnergyHandler will be called register events for watching food and water
        consumption at certain periods (for starvation and dehydration). The status_effect_manager will emit events for
        every trigger seen. For instance, Starvation and hydration trigger at the same tick, so after calling their
        update_tick, an attribute on the status is read 'triggered' that gives a list of all the times it triggered.
        The manager will then emit events for each tick the trigger occurred "dehydration_trigger", "starvation_trigger", etc.
        The id of the entity will be passed along, and the trigger can be processed.

- Adding a way to differentiate status types so that every status doesnt have to be enumerated.
    IDEA: the status_set object is a type keyed dictionary, and the is_afflicted_by() queries to see if the key is present.
    To support differentiation based on status core type, add and remove can determine if each status added inherits from
    one of the core types of interest.

    e.g.
    add(status_type: type) or remove
        # Care about
        # TriggeredStatus: Are triggered after a tick_update (and should emit an event)
        # PeriodicStatus: Are updated with tick_update on the next relevant tick
        # AperiodicStatus: Are not updated ever with tick_update.
        if issubclass(status_type, TriggeredStatus):
            # Add to dictionary under TriggeredStatus


- Adding and managing the modifiers

### FEATURE IDEA ###
Due to balancing concerns, the time frames between micro-gurps and macro-gurps could create a nightmare for simulation.
Add an option to compress or expand time:

Reasoning:
Having every second being simulated when macro-gurps deals with hours and days could be excruciating to test out features.
Time dilation controls could scale time to divide based on the day, e.g. instead of 86,400 iterations per day, a factor
of 10x could make only 8640 turns per day (easier to simulate longer term behaviors).

Other things might need to be done to ease computation, such as if an entity is not in the observation area of any other
entity and the entity is resting / sleeping, dont consider it an actor.


### IDEA ###
Combat states (for determining if an actor is 'in combat')
Required to determine if an actor can rest.

Any combat action between two entities will cause combat to start.
Combat is exited after a fixed time (10 seconds?)

### IDEA ###
Metrics idea for the energy system.
Track the number of FP points gained/spent by each entity (to see utilization of energy)
Track the number of meals and drinks consumed.


### FEATURE ###
For display purposes, have a map for every HumanView that assigns easier names for each entity / being
(instead of the UUID used in the engine). The mapping will transform the easier labels to UUIDs when they are used in
the engine.

- Ability to change the labels of particular entities (for marking interesting behavior perhaps)

### FEATURE ###
a system to not to create and load every component for the world on the screen.
Requires navigation arrows to move around, signaling the new components to render (and old ones to cull).
further optimizations required to lower the memory footprint of the grid system
    Areas of interest, areas around actors should be properly cached in memory.
    Areas outside a certain radius should be unloaded and saved to disk (sqlite?)
    Attempting to access a certain area outside of loaded cache bounds would cause a miss, and result in a chunk load into memory.








### PERFORMANCE NOTES ###
Did a simple test with a behavior that only yields when it is asked to act.
num actors | t/s
1 | 2100
2 | 950
3 | 560
4 | 370
5 | 275

First glance is ~ 1/n for n actors.
Further analysis shows that there is a constant cost in SINGLE ACTOR performance per turn.
This is due to the subjective state generation (the grid model is copied EVERY turn)
A better way would be to use the objective grid, and to manage entities in a subjective grid through observations.

### NEW FEATURE ###
Better grid management.

Goals:
- Scalability:
    Support very large grids by using a chunking system. Chunks will be stored on disk (maybe sqlite) and loaded only
    when needed. This will remove the memory footprint for large worlds.

    Very large grids are sparse. Create a system for representing only areas that have data to save space.

- Performance:
    Current grid system is copied every turn for the subjective state, which is wildly inefficient.
    A different feature with observations will describe this solution, but it may depend on the new grid chunk system.

### NEW FEATURE ###
Observation System

Represent subjective states as a collection of different observations given to an actor for different observation actions.

# DONE #-LocationObservation:
    An object that describes the position of a particular entity.
    The location can be fuzzy, depending on the degree of success the actor has on a perception roll (and the distance from the actor).

    Granted from two different types of observation action:
    # DONE # - Passive perception: "plain sight" perception that is rolled every turn. Can only return a fuzzy location, unless
        the action critically succeeds.
    - Direct perception: can only be attempted when an existing LocationObservation is present. It improves the accuracy of
        the passive perception if successful, nothing if failed, or worsens if critical fail.

-VisualObservation:
    An object that describes the information known about a particular entity.
    Can represent a multitude of different attributes, but mainly everything related to the entities model.

    Granted from two different types of observation action:
    - Passive perception: "plain sight" perception that is rolled every turn. Can only provide plain sight or easily
        inferred attributes. Examples of plain sight attributes:
            - Active weapon
            - Worn armor (non concealed)
            - Roll results (success or fail) and stats involved (maybe not skills?) of actors in sight. (this will allow the AI to extrapolate the
            relative value of stats without giving it as explicit information.

    - Direct perception: provides information about advantages, disadvantages, HP and FP (since its easy to see
    damage / exhaustion). Adv/dis will have a observation difficulty to make certain ones harder / impossible to observe.

Storing observations:
- Each being will have an entry in a manager that contains all the current observations made.
- An ObservationSet will contain all the information an entity has on each other entity it can see.
    - The set can be queried by target_id, or the subject of the observation.
    - Each target will have a type-set of observations (key is the type of the observation type)

Managing observations:
- All observations will be granted by the ObserveAction.
    - Passive observations will not specify a target while direct will.
    - A passive observe action will be injected into the action-set of every actor that can currently perceive.
    These observations generated will be used to craft the subjective state of the actor.
    - Adding an observe action will require state to potentially be generated every action resolution.



### Performance ###
Fixed lots of calls to multivariate_normal (bogged down the speed big time). Now it is if it wasnt there.

Lots of calls to cubic_to_offset, meaning there is lots of translation that may not be needed.
    - To solve, maybe make grid_model work exclusively with offset coordinates. Will have to investigate.
    - Deep copy also seeing lots of use. Maybe remove it from the grid (since get_contents may not even matter if the
    refs they pass back are the real).